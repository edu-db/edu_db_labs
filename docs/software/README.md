# Реалізація інформаційного та програмного забезпечення

В рамках проекту розробляється: 
- SQL-скрипт для створення на початкового наповнення бази даних

``` sql
-- MySQL Script generated by MySQL Workbench
-- Sun May 28 00:10:09 2023
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema mediacontent
-- -----------------------------------------------------
DROP SCHEMA IF EXISTS `mediacontent` ;

-- -----------------------------------------------------
-- Schema mediacontent
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `mediacontent` DEFAULT CHARACTER SET utf8 ;
USE `mediacontent` ;

-- -----------------------------------------------------
-- Table `mediacontent`.`users`
-- -----------------------------------------------------

DROP TABLE IF EXISTS `mediacontent`.`users` ;

CREATE TABLE IF NOT EXISTS `mediacontent`.`users` (
  `id` int AUTO_INCREMENT,
  `name` varchar(32) NOT NULL,
  `password` varchar(32) NOT NULL,
  `email` varchar(32) NOT NULL,
  `role` int NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;

-- -----------------------------------------------------
-- Table `mediacontent`.`help`
-- -----------------------------------------------------

CREATE TABLE IF NOT EXISTS `mediacontent`.`help` (
  `id` int AUTO_INCREMENT,
  `question` TEXT NOT NULL,
  `answer` TEXT DEFAULT NULL,
  `status` enum('unresolved', 'resolved') NOT NULL DEFAULT 'unresolved',
  PRIMARY KEY (`id`)) 
  ENGINE = InnoDB;

-- -----------------------------------------------------
-- Table `mediacontent`.`statistics`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mediacontent`.`statistics` ;

CREATE TABLE IF NOT EXISTS `mediacontent`.`statistics` (
  `id` INT AUTO_INCREMENT,
  `user` VARCHAR(45) NOT NULL,
  `media_count` INT NULL DEFAULT NULL,
  `last_login` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mediacontent`.`content`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mediacontent`.`content` ;

CREATE TABLE IF NOT EXISTS `mediacontent`.`content` (
  `id` INT AUTO_INCREMENT,
  `title` VARCHAR(45) NULL DEFAULT NULL,
  `description` TEXT NULL DEFAULT NULL,
  `markers` VARCHAR(255) NULL DEFAULT NULL,
  `url` LONGTEXT NULL DEFAULT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mediacontent`.`marker`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mediacontent`.`marker` ;

CREATE TABLE IF NOT EXISTS `mediacontent`.`marker` (
  `id` INT AUTO_INCREMENT,
  `name` VARCHAR(45) NULL DEFAULT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;

SELECT User, Host FROM mysql.user;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;

```

- RESTfull сервіс для управління даними
**main.py**
```python
import config
import fastapi
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import pymysql
import datetime

app = FastAPI()
class DataBase(object):
    user = config.user
    password = config.password

    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(DataBase, cls).__new__(cls)
        return cls.instance
    def __init__(self):
        self.connection = None
        self.cursor = None
        self.__connect()
    def __connect(self):
        self.connection = pymysql.connect(  
        host=config.host,
        port=3306,
        user=self.user,
        password=self.password,
        database=config.db_name
        )
        self.cursor = self.connection.cursor(pymysql.cursors.DictCursor)
    def execute(self, command): 
        self.cursor.execute(command) 
        result = self.cursor.fetchall()
        self.connection.commit() 
        return result

@app.get("/api/users")
async def get_users():
    db = DataBase() 
    return JSONResponse(db.execute('SELECT * FROM users'))

@app.get('/api/user/{id}')
def get_user_by_id(id):
    db = DataBase()  
    result = db.execute(f'SELECT * FROM users WHERE id={id}') 
    if not result: 
        raise fastapi.HTTPException(status_code=404)
    return JSONResponse(result)

@app.get("/api/questions")
async def get_questions():
    db = DataBase() 
    return JSONResponse(db.execute('SELECT * FROM help'))

@app.get('/api/question/{id}')
def get_question_by_id(id):
    db = DataBase()  
    result = db.execute(f'SELECT * FROM help WHERE id={id}') 
    if not result: 
        raise fastapi.HTTPException(status_code=404)
    return JSONResponse(result)

@app.get("/api/contents")
async def get_questions():
    db = DataBase() 
    return JSONResponse(db.execute('SELECT * FROM content'))

@app.get('/api/content/{id}')
def get_question_by_id(id):
    db = DataBase()  
    result = db.execute(f'SELECT * FROM content WHERE id={id}') 
    if not result: 
        raise fastapi.HTTPException(status_code=404)
    return JSONResponse(result)

@app.get("/api/markers")
async def get_questions():
    db = DataBase() 
    return JSONResponse(db.execute('SELECT * FROM marker'))

@app.get('/api/marker/{id}')
def get_question_by_id(id):
    db = DataBase()  
    result = db.execute(f'SELECT * FROM marker WHERE id={id}') 
    if not result: 
        raise fastapi.HTTPException(status_code=404)
    return JSONResponse(result)

@app.get("/api/stats")
async def get_stats():
    db = DataBase() 
    try:
        result = db.execute('SELECT * FROM statistics')
    except pymysql.err.OperationalError as e:
        raise fastapi.HTTPException(status_code=500, detail=f"Error getting statistics: {e}")
    return JSONResponse(result)

@app.get('/api/stat/{id}')
def get_stat_by_id(id):
    db = DataBase()  
    try:
        result = db.execute(f'SELECT * FROM statistics WHERE id={id}') 
    except pymysql.err.OperationalError as e:
        raise fastapi.HTTPException(status_code=500, detail=f"Error getting statistics: {e}")
  
    if not result: 
        raise fastapi.HTTPException(status_code=404)
    return JSONResponse(result)

@app.patch('/api/user/{id}')
def set_connect_data(id):
    db = DataBase()

    if not int(id):
        new_user = config.user
        new_password = config.password
    else:
        
        if not db.execute(f'SELECT * FROM users WHERE id={id}'):
            raise fastapi.HTTPException(status_code=404)

        new_password = db.execute(f"SELECT password FROM users WHERE id={id};")[0]["password"]

        if not new_password:
            raise fastapi.HTTPException(status_code=404)
        
        new_user = f"User({id})"

    DataBase.user = new_user 
    DataBase.password = new_password 

    media_count = db.execute("SELECT COUNT(*) FROM content")[0]["COUNT(*)"]

    current_time = datetime.datetime.now()
    current_time_str = current_time.strftime('%Y-%m-%d %H:%M:%S')

    db.execute(f"INSERT INTO `statistics`(`user`, `media_count`, `last_login`) " 
    f"VALUES ('{new_user}','{media_count}', '{current_time_str}');")

    return JSONResponse({'message': f"Connected as {DataBase.user}"})

@app.post('/api/user', status_code=201)
async def add_new_user(req: Request):  
    req_dict = await req.json() 
    try:
        name = req_dict['name']
        password = req_dict['password'] 
        email = req_dict['email'] 
        role = req_dict['role']
    except:     
        raise fastapi.HTTPException(status_code=400)
    db = DataBase()

    existing_user = db.execute(f"SELECT * FROM `users` WHERE `email` = '{email}'")

    if existing_user:
        raise fastapi.HTTPException(status_code=409, detail='User with the same email already exists.')
    
    try:
        db.execute(f"INSERT INTO `users`(`name`, `password`, `email`, `role`) " 
        f"VALUES ('{name}','{password}','{email}',{role});")
    except pymysql.err.OperationalError as e:
        raise fastapi.HTTPException(status_code=500, detail=f"Error adding users data: {e}")
    
    id = db.execute(f"SELECT id FROM users WHERE email='{email}';")[0]['id']
    db.execute(f"CREATE USER 'User({id})'@'localhost' IDENTIFIED BY '{password}';")
    setRole(id, role)

    return {'message':'New user added!'}

@app.post('/api/question', status_code=200)
async def add_question(req: Request):  
    req_dict = await req.json() 
    try:
        question = req_dict['question']
    except:     
        raise fastapi.HTTPException(status_code=400)
    db = DataBase()
    
    db.execute(f"INSERT INTO `help`(`question`) VALUES ('{question}');")

    return {'message':'New question added!'}

@app.post('/api/content', status_code=200)
async def add_content(req: Request):  
    req_dict = await req.json() 
    try:
        title = req_dict['title']
        description = req_dict['description'] 
        markers = req_dict['markers'] 
        url = req_dict['url']
    except:     
        raise fastapi.HTTPException(status_code=400)
    db = DataBase()
    
    existing_url = db.execute(f"SELECT * FROM `content` WHERE `url` = '{url}'")

    if existing_url:
        raise fastapi.HTTPException(status_code=409, detail='Content with the same url already exists.')

    table_markers = db.execute('SELECT * FROM marker')
    if table_markers:
        for marker in table_markers:
            marker_name = marker['name']
            markers += f", {marker_name}"
            
    try:
        db.execute(f"INSERT INTO `content`(`title`, `description`, `markers`, `url`) " 
        f"VALUES ('{title}','{description}','{markers}','{url}');")
    except pymysql.err.OperationalError as e:
        raise fastapi.HTTPException(status_code=500, detail=f"Error adding content data: {e}")

    return {'message':'New content added!'}

@app.post('/api/marker', status_code=200)
async def add_marker(req: Request):  
    req_dict = await req.json() 
    try:
        name = req_dict['name']
    except:     
        raise fastapi.HTTPException(status_code=400)
    db = DataBase()
    
    existing_name = db.execute(f"SELECT * FROM `marker` WHERE `name` = '{name}'")

    if existing_name:
        raise fastapi.HTTPException(status_code=409, detail='Marker with the same name already exists.')

    try:
        db.execute(f"INSERT INTO `marker`(`name`) VALUES ('{name}');")
    except pymysql.err.OperationalError as e:
        raise fastapi.HTTPException(status_code=500, detail=f"Error adding marker: {e}")

    contents = db.execute("SELECT * FROM `content`;")

    if contents:
        for content in contents:
            markers = content.get('markers', '')
            markers += f", {name}"
            db.execute(f"UPDATE `content` SET `markers` = '{markers}' WHERE `id` = {content['id']};")

    return {'message':'New marker added!'}


@app.put('/api/user/{id}')
async def update_user(id, req: Request):
    req_dict = await req.json() 
    db = DataBase()
    for key in req_dict:  
        if not db.execute(f'SELECT * FROM users WHERE id={id}'):
            raise fastapi.HTTPException(status_code=404)
        try:
            if key == "role":
                db.execute(f"REVOKE ALL PRIVILEGES ON *.* FROM 'User({id})'@'localhost';")
                setRole(id, req_dict[key])
            db.execute(f'UPDATE users SET {key}="{req_dict[key]}" WHERE id={id}')
        except pymysql.err.OperationalError as e:
            raise fastapi.HTTPException(status_code=500, detail=f"Error updating user data: {e}")

    return {"message":'Updated!'}

@app.put('/api/answer/{id}')
async def update_answer(id, req: Request):
    req_dict = await req.json() 
    answer = req_dict["answer"]
    db = DataBase()

    if not db.execute(f'SELECT * FROM help WHERE id={id}'):
        raise fastapi.HTTPException(status_code=404)
    try:
        db.execute(f'UPDATE help SET answer="{answer}" WHERE id={id}')
    except pymysql.err.OperationalError as e:
        raise fastapi.HTTPException(status_code=500, detail=f"Error updating answer: {e}")
    db.execute(f'UPDATE help SET status="resolved" WHERE id={id}')

    return {"message":'Answer updated!'}

@app.put('/api/content/{id}')
async def update_content(id, req: Request):
    req_dict = await req.json() 
    db = DataBase()
    for key in req_dict:  
        if not db.execute(f'SELECT * FROM content WHERE id={id}'):
            raise fastapi.HTTPException(status_code=404)
        try:
           db.execute(f'UPDATE content SET {key}="{req_dict[key]}" WHERE id={id}')
        except pymysql.err.OperationalError as e:
            raise fastapi.HTTPException(status_code=500, detail=f"Error updating content data: {e}")

    return {"message":'Updated!'}

@app.put('/api/marker/{id}')
async def update_content(id, req: Request):
    req_dict = await req.json() 
    name = req_dict["name"]
    db = DataBase()
    if not db.execute(f'SELECT * FROM marker WHERE id={id}'):
        raise fastapi.HTTPException(status_code=404)
    try:
        contents = db.execute("SELECT * FROM `content`")
        old_marker = db.execute(f'SELECT name FROM marker WHERE id={id}')[0]["name"]

        for content in contents:
            markers = content['markers'].split(',')
            new_markers = [marker.replace(old_marker, name) if marker.strip() == old_marker.strip() else marker for marker in markers]
            new_markers_str = ','.join(new_markers)
            db.execute(f'UPDATE content SET markers="{new_markers_str}" WHERE id={content["id"]}')

        db.execute(f'UPDATE marker SET name="{name}" WHERE id={id}')
    except pymysql.err.OperationalError as e:
        raise fastapi.HTTPException(status_code=500, detail=f"Error updating marker: {e}")

    return {"message":'Updated!'}


@app.delete('/api/user/{id}')
def delete_user(id):
    db = DataBase()
    if not db.execute(f'SELECT * FROM users WHERE id={id}'):
        raise fastapi.HTTPException(status_code=404)
    try:
        db.execute(f'DELETE FROM `users` WHERE id={id}')
    except pymysql.err.OperationalError as e:
            raise fastapi.HTTPException(status_code=500, detail=f"Error deleting user: {e}")

    db.execute(f"DROP USER 'User({id})'@'localhost';")
    return {'message':f'User with id={id} deleted'}

@app.delete('/api/question/{id}')
def delete_question(id):
    db = DataBase()
    if not db.execute(f'SELECT * FROM help WHERE id={id}'):
        raise fastapi.HTTPException(status_code=404)
    try:
        db.execute(f'DELETE FROM `help` WHERE id={id}')
    except pymysql.err.OperationalError as e:
            raise fastapi.HTTPException(status_code=500, detail=f"Error deleting question: {e}")

    return {'message':f'Question with id={id} deleted'}

@app.delete('/api/content/{id}')
def delete_content(id):
    db = DataBase()
    if not db.execute(f'SELECT * FROM content WHERE id={id}'):
        raise fastapi.HTTPException(status_code=404)
    try:
        db.execute(f'DELETE FROM `content` WHERE id={id}')
    except pymysql.err.OperationalError as e:
            raise fastapi.HTTPException(status_code=500, detail=f"Error deleting content: {e}")

    return {'message':f'Content with id={id} deleted'}

@app.delete('/api/marker/{id}')
def delete_marker(id):
    db = DataBase()
    if not db.execute(f'SELECT * FROM marker WHERE id={id}'):
        raise fastapi.HTTPException(status_code=404)
    try:
        contents = db.execute("SELECT * FROM `content`")
        old_marker = db.execute(f'SELECT name FROM marker WHERE id={id}')[0]["name"]

        for content in contents:
            markers = content['markers'].split(',')
            new_markers = [marker for marker in markers if marker.strip() != old_marker.strip()]
            new_markers_str = ','.join(new_markers)
            db.execute(f'UPDATE content SET markers="{new_markers_str}" WHERE id={content["id"]}')

        db.execute(f'DELETE FROM `marker` WHERE id={id}')
    except pymysql.err.OperationalError as e:
            raise fastapi.HTTPException(status_code=500, detail=f"Error deleting marker: {e}")

    return {'message':f'Marker with id={id} deleted'}


def setRole(id, value):
    db = DataBase()
    if value == 0:
        db.execute(f"GRANT ALL PRIVILEGES ON *.* TO 'User({id})'@'localhost' WITH GRANT OPTION;")
    elif value == 1:
        tables = db.execute("SHOW TABLES;")  # Получить список всех таблиц в базе данных
        for table in tables:
            table_name = table['Tables_in_mediacontent']
            if table_name != 'statistics':  # Пропустить таблицу, на которую не нужно давать доступ
                db.execute(f"GRANT SELECT ON `mediacontent`.`{table_name}` TO 'User({id})'@'localhost';")
        db.execute(f"GRANT INSERT ON `mediacontent`.`help` TO 'User({id})'@'localhost';")
        db.execute(f"GRANT INSERT ON `mediacontent`.`statistics` TO 'User({id})'@'localhost';")
    else:
        raise fastapi.HTTPException(status_code=400, detail='Incorrect role: Write 0 for administrator or 1 for ordinary user')

```

**config.py**

```python
host = "127.0.0.1"
user = "root"
password = "12345678"
db_name = "mediacontent"
```